from celery import shared_task
import time
from .models import WireGuardInterface, WireGuardPeer, WireguardCommandLogs, PeerUsageData
from . import Wireguard
from django.conf import settings
import os
from datetime import datetime
from django.db.models import Max
import re
import math
import time
import qrcode
import qrcode.image.svg
import uuid

@shared_task
def HelloWorld():
    print('HELLO WORLD!')


#called everytime when something has to be changed for server wireguard configuration (wg0.conf)
@shared_task
def Wireguard_from_database_to_config_file():
    wireguard = Wireguard.ConfigFile(settings.WIREGUARD_CONF_FILE_PATH)


    interface = WireGuardInterface.objects.last()
    if interface == None:
        interface = WireGuardInterface()

    peers = []

    for peer in WireGuardPeer.objects.all():
        peers.append({
            'PublicKey':peer.PublicKey,
            'AllowedIPs':peer.Address,
            'PreSharedKey':peer.PreSharedKey,
        })

    wireguard.set_config({
        'Interface':{
            'Address':interface.Address,
            'SaveConfig':interface.SaveConfig,
            'ListenPort':interface.ListenPort,
            'PrivateKey':interface.PrivateKey,
        },
        'Peers':peers,
        #for settings extra rules after interface
        'UFW':settings.WIREGUARD_CONFIG_FILE_AFTER_INTERFACE, 
    })
@shared_task
def Restart_wireguard():
    exec(settings.WIREGUARD_COMMAND_TO_RESTART) #TODO some more general way

    

#for deleting config files in templatets/generated_files and qrcodes
@shared_task
def Delete_File(file_path):
    if os.path.exists(file_path):    
        os.remove(file_path)
    

#deletes everything apart from .gitkeep from generated_files and generated_qr_codes
@shared_task
def CleanGenerated():
    #generated_files
    folder_path = settings.CLIENT_CONFIG_FILE_FOLDER
    generated_files = [os.path.join(folder_path, f) for f in os.listdir(folder_path) if os.path.isfile(os.path.join(folder_path, f))]


    for file_path in generated_files:
        if '.gitkeep' in file_path:
            pass
        else:
            Delete_File(file_path)


    #generated_qr_codes
    folder_path = settings.CLIENT_CONFIG_FILE_FOLDER_QR_CODE
    generated_qr_codes = [os.path.join(folder_path, f) for f in os.listdir(folder_path) if os.path.isfile(os.path.join(folder_path, f))]

    for file_path in generated_qr_codes:
        if '.gitkeep' in file_path:
            pass
        else:
            Delete_File(file_path)



#Used for loading logs generated by scripts running on host to get all info about connections and trasfer it to this database
#must be run only from celery. Due to the fact that it has the volume mounted to it
#args: seconds_in_the_past (how many seconds in the past should it look (on what files))
@shared_task
def Load_Host_Wireguard_Logs(seconds_in_the_past=-1):
    folder_path = settings.WIREGUARD_LOGS_PATH
    # Get a list of all files in the folder
    
    if seconds_in_the_past == -1:
        #Get all
        files = [f for f in os.listdir(folder_path) if os.path.isfile(os.path.join(folder_path, f))]
    else:
        #get only made in the seconds_in_the_past
        current_time = time.time()
        time_ago = current_time - seconds_in_the_past
        files = [
            f for f in os.listdir(folder_path)
            if os.path.isfile(os.path.join(folder_path, f)) and os.path.getctime(os.path.join(folder_path, f)) >= time_ago
        ]

    # Print the list of files
    for file in files:
        try:
            #getting epoch time
            date_time_str = file.replace(".txt", "")
            date_time_format = "%Y-%m-%d_%H-%M-%S"
            date_time_obj = datetime.strptime(date_time_str, date_time_format)
            epoch_time = date_time_obj.timestamp()
            
            if WireguardCommandLogs.objects.filter(epoch_time=epoch_time).count() > 0:
                #this log file is already registered
                continue

            file_path = folder_path + "/"+file
            data = 'ERROR' #ERROR in case something bad happens

            #reading the string
            try:
                # Open the file for reading
                with open(file_path, 'r') as file:
                    # Read the entire content of the file into a string
                    data = file.read()
                    
            except FileNotFoundError:
                print(f"The file '{file_path}' does not exist.")
            except Exception as e:
                print(f"An error occurred: {str(e)}")


            #saving to database
            instance = WireguardCommandLogs()
            instance.epoch_time = epoch_time
            instance.text = data
            instance.save()
        except Exception as e:
            print('Cant read file',file)   

#PeerUsageData
# It will read WireguardCommandLogs and trasfer these data into PeerUsageData      
@shared_task
def Calculate_PeerUsageData():
    largest_epoch_time = PeerUsageData.objects.aggregate(Max('epoch_time'))['epoch_time__max']


    #Get WireguardCommandLogs thich i didnt proccessed
    if largest_epoch_time is None:
        command_logs = WireguardCommandLogs.objects.all()
    else:
        command_logs = WireguardCommandLogs.objects.filter(epoch_time__gt=largest_epoch_time)

    
    for log in command_logs:
        text = log.text
        if ('preshared key: (hidden)' in text):
            #now everthing is with preshared key
            peer_info_matches = re.findall(r'peer: (.*?)\s+preshared key: (.*?)\s+endpoint: (.*?)\s+allowed ips: (.*?)\s+latest handshake: (.*?)\s+transfer: (.*?) received, (.*?) sent', text, re.DOTALL)
        else: 
            #old version
            peer_info_matches = re.findall(r'peer: (.*?)\s+endpoint: (.*?)\s+allowed ips: (.*?)\s+latest handshake: (.*?)\s+transfer: (.*?) received, (.*?) sent', text, re.DOTALL)
        for match in peer_info_matches:
            try:
                public_key, endpoint, allowed_ips, latest_handshake, received, sent = match
            except Exception as e:
                public_key, preshared_key, endpoint, allowed_ips, latest_handshake, received, sent = match
            
            instance = PeerUsageData()
            instance.epoch_time = log.epoch_time #epoch time of the measuarement
            instance.peer_public_key = public_key or -1
            instance.Endpoint = endpoint or -1
            instance.AllowedIPs = allowed_ips or -1

            try:
                if 'Now' in latest_handshake:
                    instance.Latest_Handshake = 0
                else:
                    numbers = re.findall(r'\d+', latest_handshake)
                    if len(numbers) == 0:
                        instance.Latest_Handshake = 0
                    elif len(numbers) == 1:
                        instance.Latest_Handshake = int(numbers[0])
                    elif len(numbers) == 2:
                        instance.Latest_Handshake = int(numbers[0]) * 60 + int(numbers[1])
                    else:
                        instance.Latest_Handshake = -1
            except Exception as e:
                instance.Latest_Handshake = -1

            #B, KiB, MiB, GiB
            #1 B (byte) = 1 byte
            #1 KiB (kibibyte) = 1024 bytes
            #1 MiB (mebibyte) = 1024 KiB = 1,048,576 bytes #THIS IS THE STORAGE UNIT
            #1 GiB (gibibyte) = 1024 MiB = 1,048,576 KiB = 1,073,741,824 bytes

            #numbers from string to one float. "Hello 123 World 456"(str) -> 123456(float)
            combined_number = float("".join(re.findall(r'\d+\.\d+|\d+', received))) #chatgpt...
            combined_number = math.floor(combined_number)
            if 'GiB' in received:
                instance.Transfer_Received_MiB = combined_number * 1024
            elif 'MiB' in received:
                instance.Transfer_Received_MiB = combined_number
            elif 'KiB' in received or 'B' in received:
                instance.Transfer_Received_MiB = 0 #i dont care about these low numbers
            else:
                instance.Transfer_Received_MiB = -1 #something is wrong here...
            
            combined_number = float("".join(re.findall(r'\d+\.\d+|\d+', sent))) #chatgpt...
            combined_number = math.floor(combined_number)
            if 'GiB' in sent:
                instance.Transfer_Sent_MiB = combined_number * 1024
            elif 'MiB' in sent:
                instance.Transfer_Sent_MiB = combined_number
            elif 'KiB' in sent or 'B' in sent:
                instance.Transfer_Sent_MiB = 0 #i dont care about these low numbers
            else:
                instance.Transfer_Sent_MiB = -1 #something is wrong here...
                
            #save it.
            instance.save()

    

#generates string of peer for config
@shared_task
def GenerateConfigFile(peer:WireGuardPeer) -> str:
    # This what client needs to add to his local wireguard.
    client_config_wireguard = {
        "Interface": {
            "PrivateKey": peer.PrivateKey,
            "Address": peer.Address,
            "DNS": peer.DNS,
        },
        "Peers": [
            {
                "PublicKey": peer.ServerPublickey,
                "AllowedIPs": peer.AllowedIPs,
                "Endpoint": peer.Endpoint,
                "PreSharedKey": peer.PreSharedKey,
            }
        ],
    }
    if peer.KeepAlive != 0:
        client_config_wireguard['Peers'][0]['PersistentKeepalive'] = peer.KeepAlive
    
    text = Wireguard.ConfigFile('').create_config_string(
        client_config_wireguard
    )
    return text


#enter config string and this will generate config qrcode and returns a qrcode filename
@shared_task
def CreateQRConfigFile(config) -> str:
    qr = qrcode.QRCode(
        version=3,  # Specify the version here
        error_correction=qrcode.constants.ERROR_CORRECT_L,
        border=0,
    )
    qr.add_data(config)
    qr.make(fit=True)
    qr_code = qr.make_image(fill_color="black", back_color="white")
    filename = str(uuid.uuid4()) + ".png"
    qr_code_save_path = settings.CLIENT_CONFIG_FILE_FOLDER_QR_CODE + filename
    qr_code.save(qr_code_save_path)  # saving qr code
    return filename



#enter config string and this will generate file and return its filename
@shared_task
def CreateConfigFile(config) -> str:
    # creating config file
    filename = str(uuid.uuid4()) + ".conf"  # unique filename
    filepath = settings.CLIENT_CONFIG_FILE_FOLDER + filename
    #Delete_File.s(filepath).apply_async(countdown=300)
    Wireguard.ConfigFile('').save_file(filepath,config)
    return filename